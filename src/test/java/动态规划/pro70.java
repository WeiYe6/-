package 动态规划;

public class pro70 {

	public static void main(String[] args) {
		// 买卖股票III
//		题目:
//			给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
//			设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。
//			注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
//			示例 1:
//	输入：prices = [3,3,5,0,0,3,1,4]
//	输出：6
//	解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
//	随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
//			示例 4：
//			输入：prices = [1]
//			输出：0
		int[] prices = {3,3,5,0,0,3,1,4};
		int maxProfit = maxProfit(prices);
		System.out.println(maxProfit);
		
	}
	
    public static int maxProfit(int[] prices) {
    	//动规五步曲: 最多买卖两次
    	//1.dp数组含义: dp[i][0]： 不操作，不进行买卖
    	//             dp[i][1]： 第一次持有股票的最大利润
    	//             dp[i][2]：  第一次不持有股的票最大利润
    	//             dp[i][3]：  第二次持有股票的最大利润
    	//             dp[i][4]：  第二次不持有股票的最大利润
    	int[][] dp = new int[prices.length][5];
    	//2.递推公式
    	//dp[i][0] = dp[i-1][0] = 0; 没有进行过买卖操作，可以直接等于0
    	//dp[i][1] = max(dp[i-1][1], dp[i][0] 或者写 0 + (-prices[i]))：之前就持有的，或者当天持有的取最大利润
    	//dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i]): 之前就不持有的，或者当天不持有（第一次 当天卖出）
    	//dp[i][3] = max(dp[i-1][3], dp[i-1][2] + (-prices[i])): 之前就持有的，或者当天持有(有第一次先卖出-再有第二次买入)
    	//dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i])  :之前就不持有的，或者当前不持有(第二次 当天卖出)
    	//3.初始化: 
    	dp[0][0] = 0;            //第1天无操作 0
    	dp[0][1] = -prices[0];   //第1天买入
    	dp[0][2] = 0;            //第1天卖出，在同一天买入卖出当然是0了
    	dp[0][3] = -prices[0];   //第1天第二次买入
    	dp[0][4] = 0;            //第1天第二次卖出
    	//4.遍历顺序: 依靠前面的状态值，正序遍历
    	for (int i = 1; i < prices.length; i++) {
        	dp[i][0] = dp[i-1][0] = 0;
        	dp[i][1] = Math.max(dp[i-1][1], 0 + (-prices[i]));
        	dp[i][2] = Math.max(dp[i-1][2], dp[i-1][1] + prices[i]);
        	dp[i][3] = Math.max(dp[i-1][3], dp[i-1][2] + (-prices[i]));
        	dp[i][4] = Math.max(dp[i-1][4], dp[i-1][3] + prices[i]);
		}
    	//返回第二次不持有就是最大利润了，第二次包含了第一次的
		return dp[prices.length - 1][4];
    }

}
