package 动态规划;

public class pro53 {

	public static void main(String[] args) {
		// 不同的二叉搜索树 - 动态规划
		// 例子:
		// 输入： 3
		// 输出： 5
		// 推导 --- 过程
		// 给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？
//		dp[3]，就是以: 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量
//		元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量
//		元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量
//		元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量
//		有2个元素的搜索树数量就是dp[2]。
//		有1个元素的搜索树数量就是dp[1]。
//		有0个元素的搜索树数量就是dp[0]。
//		所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]
		int fn = fn(3);
		System.out.println(fn);

	}

	public static int fn(int n) {
		// 1.dp[i]含义: 以1----i为节点组成的二叉搜索树种类的累计和
		int[] dp = new int[n + 1];
		// 2. 递推公式
		//i = 3,  以1 为节点的左子树有 j - 1 = 1-1 = 0,  右子树 i - j = 3-1 = 2   ===> dp[0] * dp[2]....类推2、3为节点的
		// dp[i] += dp[j -1] * dp[i -j]
		//3.初始化 考虑到空集 也是完全二叉树 dp[0] = 1, dp[1]可以推出来
		dp[0] = 1;
		//4.遍历顺序: 因为需要前面的状态，所以采用正序遍历
		for(int i = 1; i<=n; i++) {
			for(int j = 1; j <=i; j++){
				dp[i] += dp[j - 1]*dp[i-j];
			}
		}
		return dp[n];
	}
	
	
	//数学公式巧妙解法 -  G(n)函数的值在数学上被称为卡塔兰数 Cn
	    public int numTrees(int n) {
	        // 提示：我们在这里需要用 long 类型防止计算过程中的溢出
	        long C = 1;
	        for (int i = 0; i < n; ++i) {
	            C = C * 2 * (2 * i + 1) / (i + 2);
	        }
	        return (int) C;
	    }

}
