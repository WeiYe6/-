package 真题;

import java.util.Scanner;

// 1:无需package
// 2: 类名必须Main, 不可修改
// 题目 -蜗牛 动态规划
//这题的难点主要就是要理清 棍子和 传送门以及 传送到的高度的关系
//这里我把{ 1.该棍子                        x[i]
//          2.该棍子的传送门高度            a[i]
//			3.从上一个传送门传送到该棍子的高度 b[i]   ====>1.2.3 的索引下标统一起来了x[i] a[i] b[i] 就是他们的关系
//        }
public class pro6 {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		// 在此输入您的代码...
		int n = scan.nextInt();
		long[] x = new long[n + 1]; // 第i根棍子
		long[] a = new long[n + 1]; // 第i根棍子的传送门的高度
		long[] b = new long[n + 1]; // 从上一个传送门传送到i该棍子的高度
		for (int i = 1; i <= n; i++) {
			x[i] = scan.nextLong();
		}
		for (int i = 1; i < n; i++) {
			a[i] = scan.nextLong();
			b[i + 1] = scan.nextLong();
		}
		// 动规五部曲
		//1.dp数组含义
		// dp[i][0]: 到达第i个节点所需要的最短时间
		// dp[i][1]: 到达第i个传送门所需要的最短时间
		double[][] dp = new double[n+1][2];
		//2.递推公式
		// dp[i][0]：从上一个节点 到达第i个节点有两种方式:
		// 1.直接从第i-1个节点走x轴到达第i个节点 dp[i][0] = dp[i-1][0] + (x[i] - x[i-1]}
		// 2.从第i-1个节点的传送门位置传送到 第i个节点的某高度位置,然后向下走 dp[i][0] = dp[i-1][1] + b[i]/1.3 取最小值
		//------------------------------------------
		// dp[i][1]: 从上一个节点 到达第i个节点的传送门有两种方式：
		// 1.直接从第i-1个节点的传送门传送到第i个节点的b[i]处，还要判断a[i] 和 b[i]的大小关系 决定我向上走还是向下走到达传送门的位置
		// if(a[i] >= b[i]) dp[i][1] = dp[i-1][1] + (a[i] - b[i]) /0.7 ------ 向上走
		// else   dp[i][1] = dp[i-1][1] + (b[i] - a[i]) / 1.3    -------------向下走
		// 2.从第i-1个节点的位置走x轴，然后走a[i]高度 就是第i个棍子的传送门位置了
		//   dp[i][1] = dp[i-1][0] + (x[i] - x[i-1]) + a[i] / 0.7
		
		//3.初始化：dp[0][0] dp[0][1] 表示到达第0个节点，就是x轴了，都初始化为0即可
		//dp[1][0]: 到达第一根棍子的最短时间        dp[1][0] = x[1]
		//dp[1][1]: 到达第一根棍子传送位置的最短时间dp[1][1] = x[1] + a[1]/0.7
		dp[1][0] = x[1];
		dp[1][1] = x[1] + a[1]/0.7;
		//4.遍历顺序，由递推公式可知需要由前面的状态来推导出后面的状态所以需要从左往右遍历，正序遍历
		for (int i = 2; i <= n; i++) {
			dp[i][0] = Math.min(dp[i-1][0] + (x[i] - x[i-1]), dp[i-1][1] + b[i] / 1.3);
			if (a[i] >= b[i]) {
				dp[i][1] = Math.min(dp[i-1][0] + (x[i] - x[i-1]) + a[i] / 0.7, dp[i-1][1] + (a[i] - b[i]) / 0.7);
			}else {
				dp[i][1] = Math.min(dp[i-1][0] + (x[i] - x[i-1]) + a[i] / 0.7, dp[i-1][1] + (b[i] - a[i]) / 1.3);
			}
		}
		//结果，就是走到(n,0)的位置，且要求保留两位小数
		System.out.printf("%.2f",dp[n][0]);
		scan.close();
	}
}